{"version":3,"sources":["../../src/llm/type.ts"],"sourcesContent":["export interface CompletionCallback {\n    (data: { token: string; completed: boolean }): void;\n}\n\nexport interface ILLM<\n    Instance,\n    LoadConfig,\n    LLMInferenceArguments,\n    LLMEmbeddingArguments,\n    LLMTokenizeArguments\n> {\n    readonly instance: Instance;\n\n    load(config: LoadConfig): Promise<void>;\n\n    createCompletion(\n        params: LLMInferenceArguments,\n        callback: CompletionCallback,\n        abortSignal?: AbortSignal\n    ): Promise<LLMResult>;\n\n    getEmbedding?(params: LLMEmbeddingArguments): Promise<number[]>;\n\n    getDefaultEmbedding?(text: string): Promise<number[]>;\n\n    tokenize?(content: LLMTokenizeArguments): Promise<number[]>;\n}\n\nexport interface LLMResult {\n    tokens: string[];\n    completed: boolean;\n}\n\nexport enum LLMErrorType {\n    Aborted = \"Aborted\",\n    Generic = \"Generic\",\n}\n\nexport class LLMError extends Error {\n    public readonly tokens: string[];\n    public readonly completed: boolean;\n    public readonly type: LLMErrorType;\n\n    constructor({\n        message,\n        tokens,\n        completed,\n        type,\n    }: {\n        message: string;\n        tokens: string[];\n        completed: boolean;\n        type: LLMErrorType;\n    }) {\n        super(message);\n        this.tokens = tokens;\n        this.completed = completed;\n        this.type = type;\n    }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiCO,IAAK,eAAL,kBAAKA,kBAAL;AACH,EAAAA,cAAA,aAAU;AACV,EAAAA,cAAA,aAAU;AAFF,SAAAA;AAAA,GAAA;AAKL,IAAM,WAAN,cAAuB,MAAM;AAAA,EAKhC,YAAY;AAAA,IACR;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACJ,GAKG;AACC,UAAM,OAAO;AACb,SAAK,SAAS;AACd,SAAK,YAAY;AACjB,SAAK,OAAO;AAAA,EAChB;AACJ;","names":["LLMErrorType"]}