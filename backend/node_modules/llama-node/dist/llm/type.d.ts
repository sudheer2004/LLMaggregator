interface CompletionCallback {
    (data: {
        token: string;
        completed: boolean;
    }): void;
}
interface ILLM<Instance, LoadConfig, LLMInferenceArguments, LLMEmbeddingArguments, LLMTokenizeArguments> {
    readonly instance: Instance;
    load(config: LoadConfig): Promise<void>;
    createCompletion(params: LLMInferenceArguments, callback: CompletionCallback, abortSignal?: AbortSignal): Promise<LLMResult>;
    getEmbedding?(params: LLMEmbeddingArguments): Promise<number[]>;
    getDefaultEmbedding?(text: string): Promise<number[]>;
    tokenize?(content: LLMTokenizeArguments): Promise<number[]>;
}
interface LLMResult {
    tokens: string[];
    completed: boolean;
}
declare enum LLMErrorType {
    Aborted = "Aborted",
    Generic = "Generic"
}
declare class LLMError extends Error {
    readonly tokens: string[];
    readonly completed: boolean;
    readonly type: LLMErrorType;
    constructor({ message, tokens, completed, type, }: {
        message: string;
        tokens: string[];
        completed: boolean;
        type: LLMErrorType;
    });
}

export { CompletionCallback, ILLM, LLMError, LLMErrorType, LLMResult };
